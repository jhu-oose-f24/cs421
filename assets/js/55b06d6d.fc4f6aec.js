"use strict";(self.webpackChunkcs421_f24_source=self.webpackChunkcs421_f24_source||[]).push([[565],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=i.createContext({}),l=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=l(e.components);return i.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},f=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),f=l(n),u=r,m=f["".concat(p,".").concat(u)]||f[u]||d[u]||o;return n?i.createElement(m,a(a({ref:t},c),{},{components:n})):i.createElement(m,a({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=f;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var l=2;l<o;l++)a[l]=n[l];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}f.displayName="MDXCreateElement"},3427:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var i=n(7462),r=(n(7294),n(3905));const o={id:"isp",title:"Interface segregation principle",sidebar_label:"Interface Segregation Principle"},a=void 0,s={unversionedId:"readings/wk2/isp",id:"readings/wk2/isp",title:"Interface segregation principle",description:"A class that implements an interface shouldn't be forced to implement methods it does not use.",source:"@site/docs/readings/wk2/isp.md",sourceDirName:"readings/wk2",slug:"/readings/wk2/isp",permalink:"/cs421/docs/readings/wk2/isp",draft:!1,editUrl:"https://jhu-oose-f23.github.io/cs421/docs/readings/wk2/isp.md",tags:[],version:"current",frontMatter:{id:"isp",title:"Interface segregation principle",sidebar_label:"Interface Segregation Principle"},sidebar:"tutorialSidebar",previous:{title:"Liskov Substitution Principle",permalink:"/cs421/docs/readings/wk2/lsp"},next:{title:"Dependency Inversion Principle",permalink:"/cs421/docs/readings/wk2/dip"}},p={},l=[],c={toc:l};function d(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,i.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{title:"Principle",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"A class that implements an interface shouldn't be forced to implement methods it does not use.")),(0,r.kt)("p",null,"The Interface Segregation Principle is, in a way, the same as Single Responsibility Principle, only for interfaces. It essentially says: "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"An interface should describe one set of behaviors. In other words, ",(0,r.kt)("strong",{parentName:"p"},"keep interfaces small"),'; break down a "fat" interface into several more refined interfaces.  ')),(0,r.kt)("p",null,"Here is an example: imagine your software application integrates with AWS cloud computing provider. You came up with the following design, inspired by the ",(0,r.kt)("a",{parentName:"p",href:"/cs421/docs/readings/wk2/ocp"},"Open/Closed Principle"),":"),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(5553).Z,width:"287",height:"347"})),(0,r.kt)("p",null,"You thought with this design your application is open for extension (when time comes to add another cloud computing provider) and close for modification (since you would not have to mess with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Amazon")," class that implements AWS, your current cloud computing provider). As you have anticipated, in later iterations, you add support for Dropbox to your application. The class diagram then looks like this:"),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(7950).Z,width:"390",height:"347"})),(0,r.kt)("p",null,"The problem, however, is that Dropbox does not provide the broad spectrum of behaviours declared in your ",(0,r.kt)("inlineCode",{parentName:"p"},"CloudProvider"),". So, if a client calls ",(0,r.kt)("inlineCode",{parentName:"p"},"getCDNAddress"),(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," on an object of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Dropbox")," for instance, you would have to let them know this feature is not supported by ",(0,r.kt)("inlineCode",{parentName:"p"},"Dropbox"),".",(0,r.kt)("sup",{parentName:"p",id:"fnref-2"},(0,r.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))," "),(0,r.kt)("p",null,"A better design would look like the following:"),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(7316).Z,width:"947",height:"332"})),(0,r.kt)("p",null,"In this example, one bloated interface (",(0,r.kt)("inlineCode",{parentName:"p"},"CloudProvider"),") is broken down into a set of more granular interfaces (",(0,r.kt)("inlineCode",{parentName:"p"}," CloudHostingProvider"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"CDNProvider"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"CloudStorageProvider"),"). "),(0,r.kt)("p",null,"Similar to the Single Responsibility Principle, the goal of the Interface Segregation Principle is to reduce the adverse effect of required changes by splitting the software into multiple, independent parts. "),(0,r.kt)("admonition",{title:"Case in point",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"By following this principle, you prevent bloated interfaces that define methods for multiple responsibilities. As explained in the Single Responsibility Principle, you should avoid interfaces with multiple responsibilities because they change often and make your software hard to maintain.")),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1"},"CDN is short for ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Content_delivery_network"},"Content Delivery Network"),".",(0,r.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-2"},"A common approach is to throw ",(0,r.kt)("a",{parentName:"li",href:"https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html"},(0,r.kt)("inlineCode",{parentName:"a"},"UnsupportedOperationException")),".",(0,r.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")))))}d.isMDXComponent=!0},5553:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/isp01-9bf5a0b1fd1dc862726574ce5bb2b306.png"},7950:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/isp02-afe39bf7b88949823c1bc6fb32a6bf68.png"},7316:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/isp03-57e9d994b666ca09f81aa18994bd843b.png"}}]);